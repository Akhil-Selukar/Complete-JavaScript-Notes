## 44.10 Sticky navigation.

In this section we will learn about how to implement a very common feature which you will observe in almost all the webpages in modern days. This feature is the sticky navigation, which means after scrolling the header section or a specific section the navigation bar in becomes fixed at the top of the page. This feature is very easy to implement but very effective.

In This example we want to our navigation bar appear and become fixed at the top once we scroll our header page all the way out of the screen. The very simple and easiest way to implement this is to listen to the scroll event on window object and when the window's y-coordinate is greater than the height of header element (which means we have completly scrolled the header out of the screen.) we can add the CSS class which will apply position as 'fixed' to the navbar. Below is the code to do this.

```javascript
const section1 = document.querySelector("#section--1");

const initialCoordinateOfS1 = section1.getBoundingClientRect();

window.addEventListener("scroll", function () {
  if (this.window.scrollY > initialCoordinateOfS1.top) {
    nav.classList.add("sticky");
  } else {
    nav.classList.remove("sticky");
  }
});
```

In above code we have selected the section1 element because we want our nav bar to fixed once we reaches to that section (means we cross the top coordinate of the section.). So to get these top coordinate we called [.getBoundingClientRect() function](https://github.com/Akhil-Selukar/Complete-JavaScript-Notes/tree/master/44-Advanced%20DOM/44.3-Viewboard%20coordinates%20and%20Smooth%20scrolling) on section1. Now as we want to compare the coordingate with how much user had scrolled and that we can get from the window object hence ew have added an event listner on window which will listen to each and every scroll on window. Now as soon as the window's vertical scroll becomes more than top coordinate of section1 we are adding the sticky class to navbar and as soon as the header window is back in screen we are removing the class.

This code works perfectly fine but there is one thing with respect to this code which we should consider. Have a look at below code where we have removed the if-else statement and just printing the event on console.

```javascript
const section1 = document.querySelector("#section--1");

const initialCoordinateOfS1 = section1.getBoundingClientRect();

window.addEventListener("scroll", function () {
  console.log(e);
});
```

Now in this case of you see the output on console you will a lot of scroll events getting trigger even though we are interested in the scroll event which satisfies the criteria of section1 being displayed in window. So all the other events are unnecessary, and listening to all this events can cost us performance. Hence there must be a better way to implement this. This problem is solved by using 'intersection observer APs'

Intersection Observer APIs only trigger the event when a specific element intersects with another element. For example it will only generate an eventt when section1 intersects with the window (or section1 eters the window). Even we can specify how much % of intersection must be there to trigger the event and other things. This will reduce the unnecessary events getting generated by listning to the scroll eveny on window. Have a look at below code to understand the concept and working of Intersection observer api.

```javascript
const section1 = document.querySelector("#section--1");

const observerCallback = function (entries, observer) {
  entries.forEach((entry) => {
    console.log(entry);
  });
};

const observerOptions = {
  root: null,
  threshold: [0.1, 0.2],
};

const observer = new IntersectionObserver(observerCallback, observerOptions);

observer.observe(section1);
```

Here in above code at line `const observer = new IntersectionObserver(observerCallback, observerOptions);` we have created an observer. On this observer we can call .observer() method and specify the element which need to be observed, this is what we are doing in the next line `observer.observe(section1);`.

But now still the question remains that what exactly we have to observe in given element and what exactly we have to do once we found the observation. These two things are specified by observerOptions and observerCallback respectivelly. The observerOptions is an object which specifies what exactly we have to observe while observerCallback is a callback function which defines what we have to do once the observation is received.

The observerOptions object that wehave passed has two attributes, first is the 'root', which means the reference element with which we want to observe the intersection. We have set it as 'null' means the root will be the window. Then seecond argument is 'threshold', here we can pass single value or an array. This is the percentage of intersection which must happen. Here we have passed an array [0.1, 0.2] which means first intersection will be observed when the section1 element enters or leave atlease 10% (i.e. 0.1) of the window and second intersection will be observed when the section1 element enters or leave 20% (i.e. 0.2) of the window. (Note that the intersection will be observe both the time i.e. while entering the window and while leaving the window.)

Now as soon as the intersection happens it will call the observerCallback function and pass an array of intersectionObserverEntry. These entries holds the informatiion about the intersection (This is just like an event) it will have information about the target, information about root, information like when the intersection happened, is it intersecting or not (that means entered the intersection threshold or left theintersection threshold), intersection ratio (%), intersectionRect, boundingClientRect etc. And along with that observer itself.

Now in above example we are printing the entry to the console. After scrolling sometimes if you obser the output of above code. It will call the callback function at an `intersectionRatio` of 0.1... with `isIntersection` as true. means the section1 entered the window equal to or more that 10%. Then second time callback function will be triggered and we will see `intersectionRatio` of 0.2... with `isIntersection` as true again. This means now the section1 is in window atleast 20%.

Now if we scroll in opposite direction then the next entry will be with `intersectionRatio` of 0.199... with `isIntersection` as still true. Here this event is triggered because we have came out of the intersection of 20%, but then why isIntersection is still true. This is because we have passed two conditions those are 10% intersection and 20% intersection. Now even though section1 came out of 20% intersection but it is still intersecting 10%, hence we are seeing the isIntersecting as true. If we keep on scrolling in the same direction then next entry we will see is with `intersectionRatio` of 0.099... with `isIntersection` as false. Now this time the section1 is completly out of 10% and 20% intersection and hence isIntersecting is not false.

So the main thing to notice is that here we are not generating or listning to all the unnecessary events like scrolling eventListner. we are only triggering the API and event at specified conditions only.

Now we can use this to implement the sticky navigation as below.

```javascript
const header = document.querySelector(".header");

const stickyNav = function (entries) {
  const [entry] = entries;

  if (!entry.isIntersecting) {
    nav.classList.add("sticky");
  } else {
    nav.classList.remove("sticky");
  }
};

const stickyNavOptions = {
  root: null,
  threshold: 0,
};

const headerObserver = new IntersectionObserver(stickyNav, stickyNavOptions);

headerObserver.observe(header);
```

Now here we wanted to add thesticky class to nav as soon as the header is completly out of the screen means section1 is completly in the scree. Hence we are observing the intersection on headers and the threshold is 0% means when header is 0% intersecting with window or when the header is completly out of the window.

Now in above example if we see the navigation appears eactly after the the header is gone out of window. Consider if we have content in section1 which is starting exactly at the start of the section. In that case the content will reach at the upper left conrner and then the navigation bar will appear and cover the content. This is not the good practice we want to read the content of section. So to fix this, we want to show the navbar some pixels before the header goes out of screen and that number of pixels must be equal to the height of nav bar. The one way to fix it is to adjust the threshold, but we the better way is we can specify the rootMargin in observer options which will add the margin and we can specify exact pixels of margin (Here we can't specify rem or % it has to be px.). Now we want margin from top down hence we add the -ve margin. To get the height of navbar we can use getBoundingClientRect() as below.

```javascript
const navHeight = nav.getBoundingClientRect().height;

const stickyNavOptions = {
  root: null,
  threshold: 0,
  rootMargin: `-${navHeight}px`,
};
```
